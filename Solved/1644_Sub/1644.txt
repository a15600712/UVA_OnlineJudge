1. 質數篩選（Sieve of Eratosthenes）算法:

程式碼首先通過sieve函數初始化一個布林型向量numbers，其大小為1299710（這可能基於問題的需求，選擇了一個足夠大的範圍以包含所有的查詢）。
numbers向量的每個元素代表一個數字是否為質數（false表示質數，true表示非質數）。
sieve函數將numbers[0]和numbers[1]設為true（表示1和0不是質數），然後從2開始遍歷，對於每個未被標記為非質數的數（即numbers[i]==0），
將其所有的倍數標記為非質數（numbers[j]=true），其中j是i的倍數。

2. 查詢最近的質數間隔:

對於主函數中的每次輸入input，如果numbers[input]為0（即input是質數），則輸出0，表示input本身就是質數，最近的質數間隔為0。
如果input不是質數，程式碼將分別向前和向後搜索最近的質數。對於向前搜索，從input開始遞減至2，找到第一個質數l；對於向後搜索，從input+1開始遞增，找到第一個質數r。
計算並輸出這兩個質數l和r之間的間隔，即r-l。
